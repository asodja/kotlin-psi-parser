/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package psi.parser

import org.jetbrains.kotlin.com.intellij.openapi.project.Project
import org.jetbrains.kotlin.com.intellij.psi.PsiManager
import org.jetbrains.kotlin.com.intellij.psi.impl.source.tree.PsiErrorElementImpl
import org.jetbrains.kotlin.com.intellij.testFramework.LightVirtualFile
import org.jetbrains.kotlin.idea.KotlinFileType
import org.jetbrains.kotlin.psi.KtBinaryExpression
import org.jetbrains.kotlin.psi.KtBlockExpression
import org.jetbrains.kotlin.psi.KtClass
import org.jetbrains.kotlin.psi.KtExpression
import org.jetbrains.kotlin.psi.KtFile
import org.jetbrains.kotlin.psi.KtNameReferenceExpression
import org.jetbrains.kotlin.psi.KtNamedFunction
import org.jetbrains.kotlin.resolve.BindingContext
import org.jetbrains.kotlin.resolve.calls.callUtil.getType
import psi.parser.Environment.getBindingContext
import psi.parser.Environment.newEnvironment
import java.util.concurrent.atomic.AtomicReference

class Parser {

    fun findTypeOfMyVar(): String {
        val env = newEnvironment()
        val started = System.currentTimeMillis()
        val ktFile = createKtFile(
            env.project, "SomeKtFile.kt",
            """
            class Provider(var name: String = "") {
                fun set(value: String) {
                    name = value
                }
            }
            fun createProvider() {
                val myVar = Provider("hello")
                myVar = "world"
            }
        """.trimIndent()
        )
        val bindingContext = getBindingContext(env, listOf(ktFile))

        val result = AtomicReference("")
        ktFile.children.forEach { psiElement ->
            when (psiElement) {
                is KtClass -> {}
                is KtNamedFunction -> {
                    parseFunction(psiElement, bindingContext, result)
                }
                is PsiErrorElementImpl -> {
                    println(psiElement.errorDescription)
                }
                else -> {
                    println(psiElement.text + " " + psiElement::class.java)
                }
            }
        }
        println("Parsing took: ${System.currentTimeMillis() - started}ms")

        println("Found type for myVar: " + result.get())
        return result.get()
    }

    private fun parseFunction(function: KtNamedFunction, bindingContext: BindingContext, result: AtomicReference<String>) {
        function.children.forEach { child ->
            if (child is KtBlockExpression) {
                child.children.forEach { child ->
                    when (child) {
                        is KtBinaryExpression -> {
                            parseLeft(child.left!!, bindingContext, result)
                        }
                    }
                }
            }
        }
    }

    private fun parseLeft(left: KtExpression, bindingContext: BindingContext, result: AtomicReference<String>) {
        when(left) {
            is KtNameReferenceExpression -> {
                result.set(left.getType(bindingContext).toString())
            }
        }
    }

    private fun createKtFile(project: Project, fileName: String, codeString: String) = PsiManager.getInstance(project)
        .findFile(
            LightVirtualFile(fileName, KotlinFileType.INSTANCE, codeString)
        ) as KtFile
}
